#ifndef SRC_STATE_H_
#define SRC_STATE_H_

#include <array>
#include <cassert>

#include "codon.h"
#include "constants.h"
#include "types.h"

namespace vcsmc {

// A Snippet is a small amount of bytecode, up to two opcodes with arguments,
// generated by the State object when sequencing a Codon.
struct Snippet {
 public:
  Snippet() : size(0), duration(0), should_advance_register_rotation(false) {
    bytecode.fill(0);
  }

  void Insert(uint8 byte) {
    bytecode[size] = byte;
    ++size;
    assert(size <= kSnippetMaxLength);
  }

  // Most Snippets will be short but a kWait snippet can issue up to 128 NOPs
  static const size_t kSnippetMaxLength = 128;
  std::array<uint8, kSnippetMaxLength> bytecode;
  size_t size;
  // Duration is always in units of CPU cycles.
  uint32 duration;
  // When this snippet is applied, if true, the register usage will update the
  // timing values stored to use for register rotation in sequencing.
  bool should_advance_register_rotation;
};

// Tracks current state of TIA and registers. Used in sequencing codons into
// opcodes.
class State {
 public:
  State(uint32 current_time = 0);

  Snippet Sequence(Codon codon) const;
  // Given the supplied Snippet, interpret the bytecode and update the State.
  void Apply(const Snippet& snippet);

  uint8* tia() { return tia_.data(); }
  uint8* registers() { return registers_.data(); }

  // Accessors mostly used for testing.
  uint32* register_last_used() { return register_last_used_.data(); }
  uint32 current_time() { return current_time_; }
  void set_current_time(uint32 time) { current_time_ = time; }

 private:
  std::array<uint8, TIA_COUNT> tia_;
  std::array<uint8, REGISTER_COUNT> registers_;
  std::array<uint32, REGISTER_COUNT> register_last_used_;
  uint32 current_time_;
};

}

#endif  // SRC_STATE_H_

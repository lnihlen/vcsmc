// check - compares a binary and sim image to a screenshot from Stella

#include <cassert>
#include <cstdio>
#include <fcntl.h>
#include <memory>
#include <stdio.h>
#include <string>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>
#include <vector>

#include "color_table.h"
#include "image.h"
#include "image_file.h"
#include "opcode.h"
#include "range.h"
#include "state.h"
#include "types.h"

const uint32 kSimCropLinesTop = 3;
const uint32 kImageScaleFactor = 4;

const uint32 kFileBufferSize = 4096;

bool Disassemble(const std::string& bin_path,
    std::vector<std::unique_ptr<vcsmc::op::OpCode>>* opcodes) {
  int bin_fd = open(bin_path.c_str(), O_RDONLY);
  if (bin_fd < 0)
    return false;

  std::unique_ptr<uint8[]> buf(new uint8[vcsmc::kBankSize]);
  uint32 bytes_read = 0;
  while ((bytes_read = read(bin_fd, buf.get(), vcsmc::kBankSize))
      == vcsmc::kBankSize) {
    const uint8* byte_code = buf.get();
    std::unique_ptr<vcsmc::op::OpCode> opcode;
    while ((opcode = vcsmc::OpCodeFromByteCode(byte_code)) != nullptr) {
      byte_code += opcode->bytes();
      opcodes->push_back(std::move(opcode));
    }
  }
  return true;
}

// Generate a pixel-zoomed image of |img| and save it in |file_name|.
bool SaveZoomedImage(const vcsmc::Image* img, const std::string& file_name) {
  std::unique_ptr<vcsmc::Image> zoom_image(new vcsmc::Image(
      vcsmc::kFrameWidthPixels * kImageScaleFactor,
      vcsmc::kFrameHeightPixels * kImageScaleFactor));
  uint32* zoom_ptr = zoom_image->pixels_writeable();
  for (uint32 i = 0; i < vcsmc::kFrameHeightPixels; ++i) {
    const uint32* row_ptr = img->pixels() + (i * vcsmc::kFrameWidthPixels);
    uint32* zoom_row_ptr = zoom_ptr;
    for (uint32 j = 0; j < vcsmc::kFrameWidthPixels; ++j) {
      uint32 color = *(row_ptr + j);
      for (uint32 k = 0; k < kImageScaleFactor; ++k) {
        *zoom_ptr = color;
        ++zoom_ptr;
      }
    }
    // Duplicate single row of scaled pixels for the remaining rows of vertical
    // scale.
    for (uint32 k = 0; k < kImageScaleFactor - 1; ++k) {
      std::memcpy(zoom_ptr, zoom_row_ptr,
          sizeof(uint32) * vcsmc::kFrameWidthPixels * kImageScaleFactor);
      zoom_ptr += vcsmc::kFrameWidthPixels * kImageScaleFactor;
    }
  }

  return vcsmc::ImageFile::Save(zoom_image.get(), file_name);
}

std::string ABGRToRGBString(uint32 abgr) {
  char buf[16];
  snprintf(buf, 16, "'#%02x%02x%02x'",
        abgr & 0xff,           // red
        (abgr >> 8) & 0xff,    // green
        (abgr >> 16) & 0xff);  // blue
  return std::string(buf);
}

int main(int argc, char* argv[]) {
  // Parse command line.
  if (argc != 3) {
    fprintf(stderr,
      "check usage: \n"
      "  check <input frame binary.bin> <stella snapshot.png>\n"
      "check example: \n"
      "  check frame-01.bin snapshot.png\n");
    return -1;
  }

  // Load binary file, convert to OpCode objects, simulate to image. Then load
  // Stella snapshot, crop top and bottom, downsample horizontally x2, compare
  // every color.
  std::string input_binary_path(argv[1]);
  std::vector<std::unique_ptr<vcsmc::op::OpCode>> opcodes;
  if (!Disassemble(input_binary_path, &opcodes))
    return -1;

  std::string snapshot_path(argv[2]);
  std::unique_ptr<vcsmc::Image> snap_image_orig = vcsmc::ImageFile::Load(
      snapshot_path);
  if (!snap_image_orig)
    return -1;
  std::unique_ptr<vcsmc::Image> snap_image(new vcsmc::Image(
      vcsmc::kFrameWidthPixels, vcsmc::kFrameHeightPixels));
  // Snapshot images need to be cropped and are horizontally scaled by 2, so
  // we copy the colors into a buffer the same dimensions as our sim images.
  const uint32* snap_pixel = snap_image_orig->pixels() +
      kSimCropLinesTop * snap_image_orig->width();
  uint32* dest_pixel = snap_image->pixels_writeable();
  for (uint32 i = 0; i < vcsmc::kFrameHeightPixels; ++i) {
    for (uint32 j = 0; j < vcsmc::kFrameWidthPixels; ++j) {
      *dest_pixel = *snap_pixel;
      ++dest_pixel;
      snap_pixel += 2;
    }
  }

  std::vector<std::unique_ptr<vcsmc::State>> states;
  states.push_back(std::unique_ptr<vcsmc::State>(new vcsmc::State()));
  for (uint32 i = 0; i < opcodes.size(); ++i)
    states.push_back(opcodes[i]->Transform(states.rbegin()->get()));

  std::unique_ptr<vcsmc::Image> sim_image(
      new vcsmc::Image(vcsmc::kFrameWidthPixels, vcsmc::kFrameHeightPixels));
  for (uint32 i = 0; i < states.size(); ++i)
    states[i]->PaintInto(sim_image.get());

  // Build zoomed images of both our simulation and the Stella snapshot.
  SaveZoomedImage(sim_image.get(), "tools/check/sim_zoomed.png");
  SaveZoomedImage(snap_image.get(), "tools/check/snap_zoomed.png");

  int js_fd = open("tools/check/check.js", O_WRONLY | O_CREAT | O_TRUNC,
      S_IRUSR | S_IWUSR);
  if (js_fd < 0)
    return -1;
  std::unique_ptr<char[]> print_buf(new char[kFileBufferSize]);
  uint32 bytes = snprintf(print_buf.get(), kFileBufferSize,
      "// file generated by check.cc\n\n"
      "var states_table = [\n");
  write(js_fd, print_buf.get(), bytes);

  vcsmc::Range view_range(
      (vcsmc::kVSyncScanLines + vcsmc::kVBlankScanLines) *
          vcsmc::kScanLineWidthClocks,
      (vcsmc::kVSyncScanLines + vcsmc::kVBlankScanLines +
          vcsmc::kFrameHeightPixels) * vcsmc::kScanLineWidthClocks);
  for (uint32 i = 0; i < states.size(); ++i) {
    const vcsmc::State* state = states[i].get();
    bool matches = true;
    bool visible = false;
    std::string sim_colors_str = "[";
    std::string snap_colors_str = "[";
    if (!vcsmc::Range::IntersectRanges(state->range(), view_range).IsEmpty()) {
      for (uint32 j = state->range().start_time();
          j < state->range().end_time(); ++j) {
        uint32 x = j % vcsmc::kScanLineWidthClocks;
        if (x < vcsmc::kHBlankWidthClocks)
          continue;
        visible = true;
        x = x - vcsmc::kHBlankWidthClocks;
        uint32 y = (j / vcsmc::kScanLineWidthClocks) -
            (vcsmc::kVSyncScanLines + vcsmc::kVBlankScanLines);
        uint32 pixel_offset = (y * vcsmc::kFrameWidthPixels) + x;
        uint32 sim_color = *(sim_image->pixels() + pixel_offset);
        uint32 snap_color = *(snap_image->pixels() + pixel_offset);
        if (sim_color != snap_color)
          matches = false;
        sim_colors_str += ABGRToRGBString(sim_color) + ", ";
        snap_colors_str += ABGRToRGBString(snap_color) + ", ";
      }
    }

    sim_colors_str += "]";
    snap_colors_str += "]";

    if (visible) {
      // Now serialize the State to the JavaScript array in the file.
      bytes = snprintf(print_buf.get(), kFileBufferSize,
          "  {\n"
          "    colup0: %d,\n"
          "    colup1: %d,\n"
          "    colupf: %d,\n"
          "    colubk: %d,\n"
          "    ctrlpf: %d,\n"
          "    pf0: %d,\n"
          "    pf1: %d,\n"
          "    pf2: %d,\n"
          "    grp0: %d,\n"
          "    grp1: %d,\n"
          "    matches: %s,\n"
          "    sim_colors: %s,\n"
          "    snap_colors: %s,\n"
          "    p0_clock: %d,\n"
          "    p1_clock: %d,\n"
          "    start_time: %d,\n"
          "    end_time: %d,\n"
          "    action: '%s',\n"
          "    visible: true\n"
          "  },\n",
          state->tia(vcsmc::TIA::COLUP0),
          state->tia(vcsmc::TIA::COLUP1),
          state->tia(vcsmc::TIA::COLUPF),
          state->tia(vcsmc::TIA::COLUBK),
          state->tia(vcsmc::TIA::CTRLPF),
          state->tia(vcsmc::TIA::PF0),
          state->tia(vcsmc::TIA::PF1),
          state->tia(vcsmc::TIA::PF2),
          state->tia(vcsmc::TIA::GRP0),
          state->tia(vcsmc::TIA::GRP1),
          matches ? "true" : "false",
          sim_colors_str.c_str(),
          snap_colors_str.c_str(),
          state->p0_clock(),
          state->p1_clock(),
          state->range().start_time(),
          state->range().end_time(),
          i < opcodes.size() ? opcodes[i]->assembler().c_str() : "");
    } else {
      bytes = snprintf(print_buf.get(), kFileBufferSize,
          "  {\n"
          "    start_time: %d,\n"
          "    end_time: %d,\n"
          "    action: '%s',\n"
          "    visible: false\n"
          "  },\n",
          state->range().start_time(),
          state->range().end_time(),
          i < opcodes.size() ? opcodes[i]->assembler().c_str() : "");
    }
    assert(bytes < kFileBufferSize);
    write(js_fd, print_buf.get(), bytes);
  }

  bytes = snprintf(print_buf.get(), kFileBufferSize,
      "];  // end of states_table\n\n");
  write(js_fd, print_buf.get(), bytes);

  // Serialize color table.
  bytes = snprintf(print_buf.get(), kFileBufferSize,
      "var color_table = [\n");
  write(js_fd, print_buf.get(), bytes);
  for (uint32 i = 0; i < vcsmc::kNTSCColors; ++i) {
    uint32 colu = vcsmc::kAtariNTSCABGRColorTable[i];
    bytes = snprintf(print_buf.get(), kFileBufferSize, "  %s,\n",
        ABGRToRGBString(colu).c_str());
    write(js_fd, print_buf.get(), bytes);
  }

  bytes = snprintf(print_buf.get(), kFileBufferSize,
      "];  // end of color_table\n\n");
  write(js_fd, print_buf.get(), bytes);

  // A few other useful constants.
  bytes = snprintf(print_buf.get(), kFileBufferSize,
      "// a few useful constants\n"
      "var clocks_per_row = %d;\n"
      "var clocks_in_hblank = %d;\n"
      "var clocks_to_first_row = %d;\n"
      "var zoom_factor = %d;\n",
      vcsmc::kScanLineWidthClocks,
      vcsmc::kHBlankWidthClocks,
      (vcsmc::kVSyncScanLines + vcsmc::kVBlankScanLines)
          * vcsmc::kScanLineWidthClocks,
      kImageScaleFactor);
  write(js_fd, print_buf.get(), bytes);

  close(js_fd);
}
